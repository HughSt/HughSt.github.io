---
layout: post
title: Week 4 -  Analysis of spatial clustering
featured-img: clusters
---

Aim
---

To introduce methods for exploring clustering in spatial data, with a specific focus on point data

Content
-------

This post provides an introduction to methods for exploring clustering in different types of spatial data. The approaches will be explored together in R, followed by an opportunity to adapt the code and run the analysis yourself. We will end by using SatScan to identify local clusters of malaria infection.

Datasets
--------

-   Malaria point prevalence data at the village level from Burkina Faso
-   Malaria case event data and population controls from northern Namibia

First we will attached the libraries used for visualization.

{% highlight r %}
library(rgdal)
library(raster)
library(ggplot2)
library(spatstat)
library(plotrix)
library(fields)

library(leaflet)
library(plotGoogleMaps)
library(maptools)
library(RColorBrewer)
library(lattice)
library(geoR)
library(plotrix) 
{% endhighlight %}

These libraries are for spatial data management and point process analysis.

{% highlight r %}
library(sp)

# Moran's I and spatial dependencies
library(spdep) # Spatial Dependence: Weighting Schemes, Statistics and Models
library(ape) # Analyses of Phylogenetics and Evolution
library(pgirmess) # Data Analysis in Ecology

# Attach libraries for point processes
library(spatstat)
library(splancs) # K-function
library(smacpod) # Spatial scanning statistic
{% endhighlight %}

We're going to load in some malaria data from Burkina Faso and visualize it using Leaflet to see if we can initially assess if there may be evidence of spatial clustering. What do you think?

{% highlight r %}
# Open BF malaria data
BF_malaria_data <- read.csv("https://www.dropbox.com/s/bfs3pinxe1lvvxr/data_bf2_binomial.csv?dl=1", header=T)
BF_Adm_1 <- raster::getData("GADM", country="BFA", level=1)
proj4string(BF_Adm_1) <- CRS('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ')

# Calculate prevalence
BF_malaria_data$prevalence <- BF_malaria_data$positives / BF_malaria_data$examined

# What do the data look like - do you see evidence of spatial clustering?
pal = colorNumeric("Oranges", BF_malaria_data$prevalence)
leaflet(BF_malaria_data) %>% addTiles() %>% addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
                                                             fillColor= ~pal(prevalence), radius=~prevalence*10, stroke=TRUE, weight=1) %>% 
  addLegend(pal = pal, values = ~prevalence)
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-3-1.png)

Part I: Testing for spatial autocorrelation in point-level data
---------------------------------------------------------------

In this section we're going to look at some more formal statistical tests of global spatial autocorrelation. We'll look at two general ways of doing this: using 'Moran's I' and using correlograms. These can each be done using multiple different packages in R.

Approach 1: Calculate Moran's I using a distance based matrix

{% highlight r %}
hist(BF_malaria_data$prevalence)
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-4-1.png)

{% highlight r %}
library(car)  # contains a function for logistic transformation (log odds) to make more normal
BF_malaria_data$log_odds <- logit(BF_malaria_data$prevalence)
hist(BF_malaria_data$log_odds)
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-4-2.png)

{% highlight r %}
# Generate a distance matrix
BF.dists <- as.matrix(dist(cbind(BF_malaria_data$longitude, BF_malaria_data$latitude)))
dim(BF.dists) # 109 x 109 matrix of distance between all sets of points
{% endhighlight %}

    ## [1] 109 109

{% highlight r %}
# Take the inverse of the matrix values so that closer values have a larger weight and vs vs
BF.dists.inv <- 1/BF.dists
diag(BF.dists.inv) <- 0   # replace the diagonal values with zero

# Computes Moran's I autocorrelation coefficient of x giving a matrix of weights (here based on distance) 
Moran.I(BF_malaria_data$log_odds, BF.dists.inv)                 # from the "ape" package
{% endhighlight %}

    ## $observed
    ## [1] 0.0666352
    ## 
    ## $expected
    ## [1] -0.009259259
    ## 
    ## $sd
    ## [1] 0.01639855
    ## 
    ## $p.value
    ## [1] 3.690017e-06

Approach 2: Create a correlogram to explore Moran's I over different spatial lags. The "pgirmess" package requires spdep (which also has correlogram options) but is much simplier and user-friendly.

{% highlight r %}
# Calculate the maximum distance between points
maxDist<-max(dist(cbind(BF_malaria_data$longitude, BF_malaria_data$latitude)))
maxDist
{% endhighlight %}

    ## [1] 7.534414

{% highlight r %}
xy=cbind(BF_malaria_data$longitude, BF_malaria_data$latitude)
pgi.cor <- correlog(coords=xy, z=BF_malaria_data$log_odds, method="Moran", nbclass=10)   # "pgirmess" package
# coords = xy cordinates, z= vector of values at each location and nbclass = the number of bins
plot(pgi.cor) # statistically significant values (p<0.05) are plotted in red
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-5-1.png)

{% highlight r %}
pgi.cor # distclass is midpoint for the bin
{% endhighlight %}

    ## Moran I statistic 
    ##       dist.class        coef      p.value    n
    ##  [1,]  0.4121237  0.13669304 6.435709e-04 1092
    ##  [2,]  1.1618390  0.13700359 3.059924e-06 2176
    ##  [3,]  1.9115538  0.09009855 2.482029e-05 2680
    ##  [4,]  2.6612685 -0.02082828 6.589705e-01 2172
    ##  [5,]  3.4109833 -0.10323722 9.946353e-01 1376
    ##  [6,]  4.1606981 -0.16259353 9.997622e-01 1146
    ##  [7,]  4.9104129 -0.20629178 9.991684e-01  662
    ##  [8,]  5.6601277 -0.27492632 9.990240e-01  320
    ##  [9,]  6.4098425 -0.11874035 7.536360e-01  128
    ## [10,]  7.1595572 -0.25618534 7.320096e-01   20

Based on the correlogram, over what spatial lags are there evidence for spatial autocorrelation? Is this clustering positive or negative?

Compare the correlogram to the results from a semivariogram approach:

{% highlight r %}
BF_malaria_data_geo<-as.geodata(BF_malaria_data[,c("longitude","latitude","log_odds")])

# Generate and plot a binned variogram (10 bins) NB: have made for full max distance (even though likely inaccurate) for comparison
Vario<-variog(BF_malaria_data_geo,max.dist=7.53,uvec=seq(0.4121237,7.1595572,l=10))
{% endhighlight %}

{% highlight r %}
par(mfrow=c(2,1))
plot(Vario)
plot(pgi.cor)
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-7-1.png)

Approach 3: Calculate Moran's I using a binary distance matrix. For this approach, we are going to create sets of 'neighbors' based upon their proximity. This approach can be used with point data but is especially useful for areal data.

For this approach, you will need to consider what is a sensible distance to classify points as neighbors. Considerations might include the scale of analysis and the distribution of points.

{% highlight r %}
coords<-coordinates(xy) # set spatial coordinates to create a spatial object
IDs<-row.names(as.data.frame(coords))

# In this approach, we chose a distance d such that pairs of points with distances less than 
# d are neighbors and those further apart are not. 

Neigh_nb<-knn2nb(knearneigh(coords, k=1, longlat = TRUE), row.names=IDs)     # using the "spdep" package
# assigns at least one neighbor to each and calculates the distances between
dsts<-unlist(nbdists(Neigh_nb,coords)) # returns the distance between nearest neighbors for each point
summary(dsts)
{% endhighlight %}

    ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    ## 0.03727 0.12693 0.19004 0.22742 0.27488 1.10524

{% highlight r %}
max_1nn<-max(dsts)
max_1nn # maximum distance to provide at least one neighbor to each point
{% endhighlight %}

    ## [1] 1.10524

{% highlight r %}
# We create different neighbor structures based upon distance
Neigh_kd1<-dnearneigh(coords,d1=0, d2=max_1nn, row.names=IDs)   # neighbors within maximum distance
Neigh_kd2<-dnearneigh(coords,d1=0, d2=2*max_1nn, row.names=IDs) # neighbors within 2X maximum distance

nb_1<-list(d1=Neigh_kd1, d2=Neigh_kd2) # list of neighbor structures
sapply(nb_1, function(x) is.symmetric.nb(x, verbose=F, force=T))
{% endhighlight %}

    ##   d1   d2 
    ## TRUE TRUE

{% highlight r %}
# Checks for symmetry (i.e. if i is a neighbor of j, then j is a neighbor of i). Does not always hold for k-nearest neighbours
sapply(nb_1, function(x) n.comp.nb(x)$nc)
{% endhighlight %}

    ## d1 d2 
    ##  1  1

{% highlight r %}
# Number of disjoint connected subgraphs

# Plot neighbors comparing the two distances 
par(mfrow=c(2,1), mar= c(1, 0, 1, 0))
plot(xy, pch=16)
plot(Neigh_kd1, coords, col="green",add=T)
plot(xy, pch=16)
plot(Neigh_kd2, coords,col="green", add=T)
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-8-1.png)

We will assign weights to the neighbor list for the analysis.

{% highlight r %}
#assign weights; 
weights<-nb2listw(Neigh_kd1, style="W")   # row standardized binary weights, using minimum distance for one neighbor
weights                                   # "B" is simplest binary weights
{% endhighlight %}

    ## Characteristics of weights list object:
    ## Neighbour list object:
    ## Number of regions: 109 
    ## Number of nonzero links: 1914 
    ## Percentage nonzero weights: 16.10976 
    ## Average number of links: 17.55963 
    ## 
    ## Weights style: W 
    ## Weights constants summary:
    ##     n    nn  S0       S1       S2
    ## W 109 11881 109 16.44475 442.0046

We can now run the Moran's I test on log prevalence using the neighborhood matrix. How does the results compare to other approaches?

{% highlight r %}
moran.test(BF_malaria_data$log_odds , listw=weights)  #using row standardised weights
{% endhighlight %}

    ## 
    ##  Moran I test under randomisation
    ## 
    ## data:  BF_malaria_data$log_odds  
    ## weights: weights    
    ## 
    ## Moran I statistic standard deviate = 4.7332, p-value = 1.105e-06
    ## alternative hypothesis: greater
    ## sample estimates:
    ## Moran I statistic       Expectation          Variance 
    ##       0.154300895      -0.009259259       0.001194126

We can also use a simulation approach: we simulate the test statistic using random permutations of BF\_malaria\_data$log\_odds so that the values are randomly assigned to locations and the statistic is computed nsim times; we compare the observed statistic to the distribution. What do you conclude about evidence for spatial autocorrelation?

{% highlight r %}
set.seed(1234)
bperm<-moran.mc(BF_malaria_data$log_odds , listw=weights,nsim=999)
bperm
{% endhighlight %}

    ## 
    ##  Monte-Carlo simulation of Moran I
    ## 
    ## data:  BF_malaria_data$log_odds 
    ## weights: weights  
    ## number of simulations + 1: 1000 
    ## 
    ## statistic = 0.1543, observed rank = 1000, p-value = 0.001
    ## alternative hypothesis: greater

{% highlight r %}
#statistic = 0.15, observed rank = 1000, p-value = 0.001

# Plot simulated test statistics
par(mfrow=c(1,1), mar= c(5, 4, 4, 2))
hist(bperm$res, freq=T, breaks=20, xlab="Simulated Moran's I")
abline(v=0.15, col="red")
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-11-1.png)

The approach approaches examined evidence for global spatial autorrelation. Now we're going to look at local measures of clustering for point-level data. One way to do this is using 'Local Moran's I'.

{% highlight r %}
# First calculate the local Moran's I around each point based on the spatial weights object (binary based on at least one neighbor)
I <-localmoran(BF_malaria_data$log_odds, weights)                         # "spdep" package

# Print 'LISA' for each point
Coef<-printCoefmat(data.frame(I[IDs,], row.names=row.names(coords),
                              check.names=FALSE))
{% endhighlight %}

    ##                Ii       E.Ii     Var.Ii    Z.Ii Pr(z > 0)    
    ##   [1,]  0.1812462 -0.0092593  0.2357816  0.3923  0.347407    
    ##   [2,] -0.1281931 -0.0092593  0.1868702 -0.2751  0.608391    
    ##   [3,]  0.1775977 -0.0092593  0.1868702  0.4323  0.332778    
    ##   [4,]  0.1609526 -0.0092593  0.1868702  0.3937  0.346883    
    ##   [5,]  0.1415001 -0.0092593  0.1309714  0.4166  0.338494    
    ##   [6,] -0.9356236 -0.0092593  0.2357816 -1.9078  0.971790    
    ##   [7,]  0.2048078 -0.0092593  0.0890473  0.7174  0.236575    
    ##   [8,]  0.1032625 -0.0092593  0.0890473  0.3771  0.353059    
    ##   [9,]  0.6486575 -0.0092593  0.0890473  2.2048  0.013736 *  
    ##  [10,]  0.2287016 -0.0092593  0.0999165  0.7528  0.225781    
    ##  [11,] -0.0632071 -0.0092593  0.1868702 -0.1248  0.549658    
    ##  [12,]  0.0528866 -0.0092593  0.0664728  0.2410  0.404762    
    ##  [13,] -0.0312340 -0.0092593  0.0801543 -0.0776  0.530934    
    ##  [14,] -0.2745658 -0.0092593  0.0801543 -0.9371  0.825646    
    ##  [15,]  1.8953445 -0.0092593  0.0727435  7.0617 8.225e-13 ***
    ##  [16,]  0.3782145 -0.0092593  0.0523637  1.6933  0.045202 *  
    ##  [17,] -0.0770823 -0.0092593  0.0664728 -0.2631  0.603748    
    ##  [18,]  0.1661593 -0.0092593  0.0523637  0.7666  0.221664    
    ##  [19,]  0.1462169 -0.0092593  0.0610979  0.6290  0.264674    
    ##  [20,]  0.2192834 -0.0092593  0.0487673  1.0349  0.150355    
    ##  [21,]  2.6115192 -0.0092593  0.0999165  8.2911 < 2.2e-16 ***
    ##  [22,]  0.6084835 -0.0092593  0.0664728  2.3960  0.008288 ** 
    ##  [23,]  0.1432275 -0.0092593  0.0564396  0.6419  0.260482    
    ##  [24,]  0.0027566 -0.0092593  0.0801543  0.0424  0.483073    
    ##  [25,] -0.2709034 -0.0092593  0.0455704 -1.2257  0.889836    
    ##  [26,]  2.1542250 -0.0092593  0.0890473  7.2501 2.082e-13 ***
    ##  [27,]  1.6953501 -0.0092593  0.0523637  7.4492 4.695e-14 ***
    ##  [28,] -0.4303787 -0.0092593  0.0564396 -1.7726  0.961853    
    ##  [29,] -0.4505613 -0.0092593  0.0523637 -1.9285  0.973104    
    ##  [30,]  2.4251511 -0.0092593  0.0727435  9.0260 < 2.2e-16 ***
    ##  [31,]  0.0925837 -0.0092593  0.0727435  0.3776  0.352863    
    ##  [32,] -0.0311741 -0.0092593  0.0564396 -0.0922  0.536749    
    ##  [33,]  0.6410560 -0.0092593  0.0727435  2.4112  0.007951 ** 
    ##  [34,] -0.1343683 -0.0092593  0.0664728 -0.4853  0.686251    
    ##  [35,] -0.0018818 -0.0092593  0.0564396  0.0311  0.487613    
    ##  [36,] -0.5023862 -0.0092593  0.0664728 -1.9127  0.972104    
    ##  [37,]  0.0141531 -0.0092593  0.0401358  0.1169  0.453484    
    ##  [38,]  0.4099818 -0.0092593  0.0801543  1.4808  0.069328 .  
    ##  [39,]  0.0164268 -0.0092593  0.1309714  0.0710  0.471709    
    ##  [40,] -0.2754463 -0.0092593  0.0801543 -0.9402  0.826444    
    ##  [41,] -0.1260415 -0.0092593  0.0319839 -0.6530  0.743121    
    ##  [42,]  0.3626538 -0.0092593  0.0337561  2.0243  0.021472 *  
    ##  [43,]  0.0017248 -0.0092593  0.0303535  0.0630  0.474865    
    ##  [44,] -0.3378536 -0.0092593  0.0303535 -1.8861  0.970357    
    ##  [45,]  0.3010447 -0.0092593  0.0303535  1.7811  0.037450 *  
    ##  [46,]  0.0671954 -0.0092593  0.0303535  0.4388  0.330391    
    ##  [47,]  0.1493807 -0.0092593  0.0319839  0.8870  0.187527    
    ##  [48,]  0.4352201 -0.0092593  0.0337561  2.4192  0.007777 ** 
    ##  [49,] -0.1673619 -0.0092593  0.0274551 -0.9542  0.830002    
    ##  [50,]  0.4136893 -0.0092593  0.0288486  2.4901  0.006384 ** 
    ##  [51,] -0.5022262 -0.0092593  0.0249564 -3.1205  0.999097    
    ##  [52,]  0.3696506 -0.0092593  0.0664728  1.4697  0.070828 .  
    ##  [53,] -0.3096059 -0.0092593  0.0249564 -1.9012  0.971363    
    ##  [54,] -0.0141401 -0.0092593  0.0303535 -0.0280  0.511175    
    ##  [55,]  0.2041696 -0.0092593  0.0249564  1.3510  0.088344 .  
    ##  [56,]  0.0030584 -0.0092593  0.0427101  0.0596  0.476236    
    ##  [57,]  0.4841543 -0.0092593  0.0288486  2.9050  0.001836 ** 
    ##  [58,] -0.0133199 -0.0092593  0.0303535 -0.0233  0.509297    
    ##  [59,] -0.0133688 -0.0092593  0.0217940 -0.0278  0.511104    
    ##  [60,]  0.0531181 -0.0092593  0.0208677  0.4318  0.332941    
    ##  [61,]  0.1046654 -0.0092593  0.0208677  0.7886  0.215160    
    ##  [62,] -0.0494912 -0.0092593  0.0319839 -0.2250  0.588995    
    ##  [63,]  0.0720471 -0.0092593  0.0427101  0.3934  0.347004    
    ##  [64,] -0.2179338 -0.0092593  0.0319839 -1.1668  0.878358    
    ##  [65,] -0.2961410 -0.0092593  0.0664728 -1.1127  0.867083    
    ##  [66,]  0.0955202 -0.0092593  0.0319839  0.5859  0.278977    
    ##  [67,]  0.0459319 -0.0092593  0.0288486  0.3249  0.372612    
    ##  [68,]  0.9354163 -0.0092593  0.0455704  4.4253 4.816e-06 ***
    ##  [69,]  0.1305499 -0.0092593  0.0999165  0.4423  0.329136    
    ##  [70,]  0.1286256 -0.0092593  0.0261611  0.8525  0.196972    
    ##  [71,]  0.2177453 -0.0092593  0.0727435  0.8417  0.199989    
    ##  [72,] -0.0522963 -0.0092593  0.0487673 -0.1949  0.577258    
    ##  [73,] -0.0428396 -0.0092593  0.0487673 -0.1521  0.560431    
    ##  [74,] -0.0743488 -0.0092593  0.0610979 -0.2633  0.603851    
    ##  [75,]  0.0024038 -0.0092593  0.0319839  0.0652  0.474001    
    ##  [76,]  0.0305890 -0.0092593  0.0208677  0.2758  0.391332    
    ##  [77,]  0.3382428 -0.0092593  0.0427101  1.6815  0.046335 *  
    ##  [78,]  0.5167263 -0.0092593  0.0890473  1.7626  0.038981 *  
    ##  [79,] -0.0213228 -0.0092593  0.0238320 -0.0781  0.531143    
    ##  [80,] -0.0356182 -0.0092593  0.0249564 -0.1669  0.566258    
    ##  [81,]  0.0775887 -0.0092593  0.0303535  0.4985  0.309070    
    ##  [82,] -0.0709209 -0.0092593  0.0319839 -0.3448  0.634872    
    ##  [83,]  0.1307050 -0.0092593  0.0274551  0.8447  0.199137    
    ##  [84,] -0.0128502 -0.0092593  0.0337561 -0.0195  0.507797    
    ##  [85,]  0.0290511 -0.0092593  0.0337561  0.2085  0.417413    
    ##  [86,]  0.2235697 -0.0092593  0.0288486  1.3708  0.085218 .  
    ##  [87,]  0.3949081 -0.0092593  0.0427101  1.9557  0.025252 *  
    ##  [88,]  0.0760215 -0.0092593  0.0356893  0.4514  0.325843    
    ##  [89,]  0.2764567 -0.0092593  0.0890473  0.9575  0.169166    
    ##  [90,] -0.0723277 -0.0092593  0.0303535 -0.3620  0.641324    
    ##  [91,]  0.1712432 -0.0092593  0.0303535  1.0360  0.150091    
    ##  [92,]  0.2227674 -0.0092593  0.0401358  1.1582  0.123398    
    ##  [93,] -0.1641587 -0.0092593  0.0401358 -0.7732  0.780294    
    ##  [94,] -0.0853343 -0.0092593  0.0356893 -0.4027  0.656413    
    ##  [95,]  0.1452289 -0.0092593  0.0319839  0.8638  0.193840    
    ##  [96,]  0.0349493 -0.0092593  0.0564396  0.1861  0.426189    
    ##  [97,] -0.0377275 -0.0092593  0.0523637 -0.1244  0.549504    
    ##  [98,] -0.0832743 -0.0092593  0.0303535 -0.4248  0.664520    
    ##  [99,] -0.0451134 -0.0092593  0.0427101 -0.1735  0.568867    
    ## [100,] -0.5362934 -0.0092593  0.0427101 -2.5502  0.994617    
    ## [101,]  0.4692542 -0.0092593  0.0610979  1.9359  0.026440 *  
    ## [102,]  0.0136534 -0.0092593  0.0523637  0.1001  0.460121    
    ## [103,]  0.1868468 -0.0092593  0.0564396  0.8255  0.204554    
    ## [104,] -0.0086863 -0.0092593  0.0801543  0.0020  0.499193    
    ## [105,]  0.0292903 -0.0092593  0.3173007  0.0684  0.472719    
    ## [106,] -0.0203350 -0.0092593  0.0727435 -0.0411  0.516378    
    ## [107,]  0.2580123 -0.0092593  0.0564396  1.1250  0.130290    
    ## [108,]  0.0493837 -0.0092593  0.1309714  0.1620  0.435636    
    ## [109,]  0.0645350 -0.0092593  0.9694534  0.0749  0.470128    
    ## ---
    ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

{% highlight r %}
# Plot the spatial data against its spatially lagged values (the weighted mean of its neighbors)                         
nci<-moran.plot(BF_malaria_data$log_odds, listw=weights, 
                xlab="Log prevalence", ylab="Spatially lagged log prev", labels=T, pch=16, col="grey")
text(c(3,3, -5,-5),c(0.9, -1.9,0.9,-1.9), c("High-High", "High-Low", "Low-High", "Low-Low"), cex=0.8)
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-12-1.png)

{% highlight r %}
# Map points that are local outliers in the plot
infl<-apply(nci$is.inf,1,any) # find which points are statistically significant outliers
sum(infl==T)    #13 true (12% - more than would expect by chance)
{% endhighlight %}

    ## [1] 13

{% highlight r %}
x<-BF_malaria_data$log_odds
lhx<-cut(x, breaks=c(min(x), mean(x), max(x)), labels=c("L", "H"), include.lowest=T)

wx<-lag(weights,BF_malaria_data$log_odds)
lhwx<-cut(wx, breaks=c(min(wx), mean(wx), max(wx)), labels=c("L", "H"), include.lowest=T)
lhlh<-interaction(lhx,lhwx,infl,drop=T)

names<-rep("none", length(lhlh))
names[lhlh=="L.L.TRUE"]<-"LL"
names[lhlh=="H.L.TRUE"]<-"HL"
names[lhlh=="L.H.TRUE"]<-"LH"
names[lhlh=="H.H.TRUE"]<-"HH"
{% endhighlight %}

We can map the points to show the local clusters.

{% highlight r %}
BF_malaria_localM<-as.data.frame(cbind(xy,names))
colnames(BF_malaria_localM)<-c("longitude", "latitude", "names")
BF_malaria_localM[c("longitude", "latitude")] <- lapply( BF_malaria_localM[c("longitude", "latitude")], function(x) as.numeric(as.character(x)) )
factpal <- colorFactor(c( "cyan4","coral4","coral","cyan","lightgrey"), names)
leaflet(BF_malaria_localM) %>% addTiles() %>% addCircleMarkers(~longitude, ~latitude, fillOpacity=1,
                                                               color= ~factpal(names), radius=4, stroke=TRUE, weight=1) %>% 
  addLegend(pal = factpal, values = ~names, title="Class")
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-13-1.png)

#### In class assignment on Moran's I: Use the malaria point data from Ethiopia to test whether there is global spatial autocorrelation.

Which method did you use and what do you conclude?

Part II: Examining spatial point processes
------------------------------------------

In this section we're going to look at a different type of point data, point process data, and some of the tests we can use to examine spatial autocorrelation in these data.

First we are going to load malaria case data from northern Namibia.

{% highlight r %}
CaseControl<-read.csv("https://www.dropbox.com/s/hwma9q39z2axjcg/CaseControl.csv?dl=1")

#  boundary file
NAM_Adm0<-raster::getData('GADM',country='NAM',level=0)
{% endhighlight %}

We can convert the data to a SPDF and plot the cases and 'controls'

{% highlight r %}
CaseControl_SPDF <- SpatialPointsDataFrame(coords = CaseControl[,c("long", "lat")],
                                           data = CaseControl[,c("household_id", "case")])
cases<-CaseControl_SPDF[CaseControl$case==1,]
controls<-CaseControl_SPDF[CaseControl$case==0,]

# Let's plot and see what we have
case_color_scheme <- colorNumeric(c("blue", "red"), CaseControl_SPDF$case)
leaflet() %>% addTiles() %>% addCircleMarkers(data=CaseControl_SPDF, color = case_color_scheme(CaseControl_SPDF$case),
                                              radius=3)
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-15-1.png)

In the previous lecture, you already generated first order kernel density estimates and calculated the ratio of the density estimate of cases:controls. Now you will look at second order functions, summarizing the spatial dependence between events

We need to change the case data to a PPP data type ('point pattern')

{% highlight r %}
CasesPPP<-as(cases, "ppp")
{% endhighlight %}

We use Ripley's K function to summarize the spatial dependence between events at a wide range of spatial scales

{% highlight r %}
K<-Kest(CasesPPP,correction=c("isotropic", "Ripley"))    #uses the "spatstat" package

par(mfrow=c(1,1)) # Plot the estimate of K(r); note different border-corrected estimates ('iso', 'border' and 'trans')
plot(K, xlab="d (dd)", ylab="K(dd)") # Red dashed line is expected K value computed for a CRS process
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-17-1.png)

{% highlight r %}
E<-envelope(CasesPPP, Kest, nsim=999) # Plot confidence envelope using MC simulation
{% endhighlight %}

{% highlight r %}
plot(E)
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-19-1.png)

The K-function computed for cases assumes that H0 is complete spatial randomness. What are the limitations of this assumption?

Next we can look at the difference in Ripley's K function between cases and controls, using two approaches that do essentially the same thing; \#2 with hypothesis testing.

Approach 1: K function vignette from Bradley et al simply calculates the K function for cases and controls, and evaluates the difference.

First create a marked point process.

{% highlight r %}
CaseControlPPP<-ppp(CaseControl$long, CaseControl$lat, range(CaseControl$long), range(CaseControl$lat), marks = as.factor(CaseControl$case))

# Calculate the K-function for cases
KX <- Kest(CaseControlPPP[CaseControlPPP$marks==1],correction=c("isotropic", "Ripley"))
plot(KX, sqrt(iso/pi) ~ r)
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-20-1.png)

{% highlight r %}
# Calculate the K-function for controls
KY <- Kest(CaseControlPPP[CaseControlPPP$marks==0],correction=c("isotropic", "Ripley"))
plot(KY, sqrt(iso/pi) ~ r)
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-20-2.png)

{% highlight r %}
# Calulate the difference in the two functions
Kdiff <- eval.fv(KX - KY)
plot(Kdiff, legendpos="float")
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-20-3.png)

Approach 2: "Smacpod" package includes a function to estimate the difference in K function and plot simulated CI. Also includes a function to the test the significance based on these simulations.

{% highlight r %}
kdest = kdest(CaseControlPPP, case = 2,nsim=999, level=0.95, correction=c("isotropic", "Ripley"))  #"smacpod" package
# Note that the case = is position of the marks, not the value!  levels(CaseControlPPP$marks)
{% endhighlight %}

{% highlight r %}
plot(kdest) # dark grey is min/max; light grey is confidence envelope (can change these with options)
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-22-1.png)

{% highlight r %}
kdplus.test(kdest) # Performs test of significance based on simulated confidence envelope and observed statistic
{% endhighlight %}

    ## [1] "The p-value for the global test is 0.01"

Spatial Scan Statistics
-----------------------

Finally we will look at spatial scan statistics using SatScan and R

You will need to download SatScan to your computer, you can find it here: <http://www.satscan.org/>

Open the SatScan\_Practical [word document](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week4/Lab_files/SatScan_Practical.docx) and follow the instructions to identify and map clustering of cases in the Namibia data using Kulldorff's spatial scan statistic.

After running the SatScan analysis, use "smacpod" library for Kulldorf spatial scan statistic

{% highlight r %}
# Convert CaseControl to a "PPP" object for spatial scan
CaseControlPPP<-ppp(CaseControl$long, CaseControl$lat, range(CaseControl$long), range(CaseControl$lat), marks = as.factor(CaseControl$case))

out<-spscan.test(CaseControlPPP, nsim = 999, case = 2, maxd=.15, alpha = 0.05)    # "smacpod" library
plot(CaseControlPPP)
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-23-1.png)

{% highlight r %}
case_color_scheme <- colorNumeric(c("blue", "red"), CaseControl_SPDF$case)
leaflet() %>% addTiles() %>% addCircleMarkers(data=CaseControl_SPDF, color = case_color_scheme(CaseControl_SPDF$case), 
                                              stroke = FALSE, radius=2, fillOpacity=1)%>% 
  addCircles(lng = out$clusters[[1]]$coords[,1], lat = out$clusters[[1]]$coords[,2], weight = 2,
             radius = out$clusters[[1]]$r*112*1000, color="grey")
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-23-2.png)

{% highlight r %}
# Read in shapefiles from SatScan and visualize for comparison
SatScan <- readOGR("/Users/abennett1/Documents/Teaching/Spatial Epi 2019", "SatScan_output.col")
{% endhighlight %}

{% highlight r %}
SatScan@data
{% endhighlight %}

    ##   CLUSTER LOC_ID  LATITUDE LONGITUDE    RADIUS START_DATE   END_DATE
    ## 0       1   6180 -17.40294  15.93590  8.076876   2000/1/1 2000/12/31
    ## 1       2   1094 -17.40034  15.35346 23.442995   2000/1/1 2000/12/31
    ## 2       3   1041 -17.52671  14.67963 12.173393   2000/1/1 2000/12/31
    ## 3       4   1050 -17.40217  14.97562  6.195484   2000/1/1 2000/12/31
    ##   NUMBER_LOC       LLR      P_VALUE OBSERVED  EXPECTED      ODE REL_RISK
    ## 0         30 11.857999 0.0008732451       24 11.845494 2.026087 2.388235
    ## 1          9  4.982612 0.4860000000        8  3.553648 2.251208 2.370370
    ## 2          8  4.130810 0.8140000000        7  3.158798 2.216033 2.316176
    ## 3          4  3.770711 0.9710000000        4  1.579399 2.532609 2.602273
    ##   POPULATION GINI_CLUST
    ## 0         30          T
    ## 1          9          F
    ## 2          8          F
    ## 3          4          F

{% highlight r %}
leaflet() %>% addTiles() %>% addCircleMarkers(data=CaseControl_SPDF, color = case_color_scheme(CaseControl_SPDF$case), 
                                              stroke = FALSE, radius=2, fillOpacity=1)%>% 
  addCircles(lng = out$clusters[[1]]$coords[,1], lat = out$clusters[[1]]$coords[,2], weight = 2,
             radius = out$clusters[[1]]$r*112*1000, color="grey")%>% 
  addCircles(lng = SatScan$LONGITUDE[], lat = SatScan$LATITUDE[], weight = 2,
             radius = SatScan$RADIUS[]*1000, color="green")
{% endhighlight %}

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/Week-4-spatial-clustering_files/figure-markdown_github/unnamed-chunk-26-1.png)

Key Readings
------------

Pullan, R. L., H. J. Sturrock, et al. (2012). "Spatial parasite ecology and epidemiology: a review of methods and applications." Parasitology 139(14): 1870-1887.

Pfeiffer DU, Robinson TP, Stevenson M, Stevens KB, Rogers DJ & Clements ACA (2008). Spatial Analysis in Epidemiology. Chapters 4 & 5. Oxford University Press, Oxford, UK.

Other good resources
--------------------

Waller LA, Gotway CA (2004) Applied Spatial Statistics for Public Health Data. John Wiley & Sons, Hoboken, New Jersey.

-   R library rsatscan can be used to run SatScan from R, see also here: <https://www.satscan.org/rsatscan/rsatscan.html>

Selection of research applications
----------------------------------

Bejon, P., T. N. Williams, et al. (2014). "A micro-epidemiological analysis of febrile malaria in Coastal Kenya showing hotspots within hotspots." Elife 3: e02130.

Brooker S, Clarke S, Njagi JK, Polack S, Mugo B, Estambale B, Muchiri E, Magnussen P & Cox J (2004). Spatial clustering of malaria and associated risk factors during an epidemic in a highland area of western Kenya. Tropical Medicine and International Health 9: 757-766.

Fevre EM, Coleman PG, Odiit M, et al. (2001). The origins of a new Trypanosoma brucei rhodesiense sleeping sickness outbreak in eastern Uganda. Lancet 358: 625-628.

Huillard d'Aignaux J, Cousens SN, Delasnerie-Laupretre N, Brandel JP, Salomon D, Laplanche JL, Hauw JJ & Alperovitch A (2002). Analysis of the geographical distribution of sporadic Creutzfeldt-Jakob disease in France between 1992 and 1998. International Journal of Epidemiology 31: 490-495.

Gaudart J, Poudiougou B, Dicko A, et al. (2006). Space-time clustering of childhood malaria at the household level: a dynamic cohort in a Mali village. BMC Public Health 6: 286.

Kulldorff M, Athas WF, Feuer EJ, Miller BA & Key CR (1998). Evaluating cluster alarms: A Space-Time Scan Statistic and Brain Cancer in Los Alamos, New Mexico. American Journal of Public Health 88, 1377-1380.

Kulldorff M & Nagarwalla N (1995). Spatial disease clusters: Detection and inference. Statistics in Medicine 14, 799-819. Odoi A, Martin SW, Michel P, et al. (2004). Investigation of clusters of giardiasis using GIS and a spatial scan statistic. Int J Health Geogr 3: 11.

Mosha, J. F., H. J. Sturrock, et al. (2014). "Hot spot or not: a comparison of spatial statistical methods to predict prospective malaria infections." Malar J 13: 53.

Ngowi HA, Kassuku AA, Carabin H, et al. (2010). Spatial clustering of porcine cysticercosis in Mbulu district, northern Tanzania. PLoS Negl Trop Dis 4: e652.

Peterson I, Borrell LN, El-Sadr W, et al. (2009). A temporal-spatial analysis of malaria transmission in Adama, Ethiopia. Am J Trop Med Hyg 81: 944-949.

Sissoko, M. S., L. L. van den Hoogen, et al. (2015). "Spatial Patterns of Plasmodium falciparum Clinical Incidence, Asymptomatic Parasite Carriage and Anopheles Density in Two Villages in Mali." Am J Trop Med Hyg 93(4): 790-797.

Washington CH, Radday J, Streit TG, et al. (2004). Spatial clustering of filarial transmission before and after a Mass Drug Administration in a setting of low infection prevalence. Filaria J 3: 3.