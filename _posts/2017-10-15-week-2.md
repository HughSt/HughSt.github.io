---
layout: post
title: Week 2 - Manipulating spatial data
featured-img: nepal_elev
---


\#\# Week 2 - Manipulating spatial data

In week 1, you got to load up some spatial data and make some pretty
maps. This week, we will be stepping up a gear and learning how to crop
and subset spatial data. We will also be go through the process of
resampling rasters.

## Learning outcomes

By the end of this week, you will be able to:

  - Clip and subset vector and raster data
  - Resample rasters
  - Relate spatial data

Load the necessary libraries for this week

``` r
library(sp)
library(raster)
library(leaflet)
library(rgdal)
library(geosphere)
library(rgeos)
library(wesanderson)
library(stats)
```

First we are going to subset some spatial (polygon) data. For this
excersize, we are going to use the admin 2 boundaries for Burkina Faso
we used in week 1. As a reminder, we can load these in from a local
shapefile using the readOGR function, or we can use the handy `getData`
function from the `raster` package to access GADM data.

``` r
BF_Adm_1 <- raster::getData("GADM", country="BFA", level = 1)
```

You can subset a SpatialPolygonsDataFrame just like a data frame. Let’s
subset the data first by row/polygon

``` r
BF_Adm_1_cropped <- BF_Adm_1[1,]

# Get a summary of the cropped data
BF_Adm_1_cropped
```

    ## class       : SpatialPolygonsDataFrame 
    ## features    : 1 
    ## extent      : -4.650181, -2.4414, 11.23941, 13.71847  (xmin, xmax, ymin, ymax)
    ## coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
    ## variables   : 10
    ## names       : GID_0,       NAME_0,   GID_1,            NAME_1, VARNAME_1, NL_NAME_1, TYPE_1, ENGTYPE_1, CC_1, HASC_1 
    ## value       :   BFA, Burkina Faso, BFA.1_1, Boucle du Mouhoun,        NA,        NA, Région,    Region,   NA,  BF.BO

``` r
# Plot over the top of the full dataset
plot(BF_Adm_1)
lines(BF_Adm_1_cropped, col="red", lwd=2)
```

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week2_files/figure-gfm/unnamed-chunk-3-1.png)<!-- -->

You can also subset by name. For example, if we wanted to extract the
polygon representing the boundary of the province
“Cascades”

``` r
BF_Adm_1_Cascades <- subset(BF_Adm_1, BF_Adm_1$NAME_1=="Cascades") #OR BF_Adm_1[BF_Adm_1$NAME_1=="Cascades",] will also work
BF_Adm_1_Cascades
```

    ## class       : SpatialPolygonsDataFrame 
    ## features    : 1 
    ## extent      : -5.518918, -3.6731, 9.594068, 11.02283  (xmin, xmax, ymin, ymax)
    ## coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
    ## variables   : 10
    ## names       : GID_0,       NAME_0,   GID_1,   NAME_1, VARNAME_1, NL_NAME_1, TYPE_1, ENGTYPE_1, CC_1, HASC_1 
    ## value       :   BFA, Burkina Faso, BFA.2_1, Cascades,        NA,        NA, Région,    Region,   NA,  BF.CD

``` r
#Plot the result
plot(BF_Adm_1)
lines(BF_Adm_1_Cascades, col="blue", lwd=2)
```

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week2_files/figure-gfm/unnamed-chunk-4-1.png)<!-- -->

## Spatial overlays

Often, we have point and polygon data and wish to relate them. For
example, we might want to summarize point data over regions. To
illustrate this, we are going to use the Burkina Faso malaria point
prevalence data and aggregate that to provincial level to get a
provincial level estimate of prevalence.

``` r
# Get the point prevalence data from the GitHub repo
BF_malaria_data <- read.csv("https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week1/Lab_files/Data/BF_malaria_data.csv",header=T)

# Convert to a SPDF
BF_malaria_data_SPDF <- SpatialPointsDataFrame(coords = BF_malaria_data[,c("longitude", "latitude")],
                                               data = BF_malaria_data[,c("examined", "positives")],
                                               proj4string = CRS("+init=epsg:4326"))
```

To identify the Province each point lies within you can use the `over`
function from the `sp` package

    BF_Adm_1_per_point <- over(BF_malaria_data_SPDF, BF_Adm_1)
      Error in .local(x, y, returnList, fn, ...) : identicalCRS(x, y) is not TRUE

This throws an error, because `BF_malaria_data_SPDF` and `BF_Adm_1` do
not have exactly the same coordinate reference system (CRS). Let’s take
a look

``` r
crs(BF_Adm_1)
```

    ## CRS arguments:
    ##  +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0

``` r
crs(BF_malaria_data_SPDF)
```

    ## CRS arguments:
    ##  +init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84
    ## +towgs84=0,0,0

To reproject to the same CRS, you can use the `spTransform` function
from the `sp` package

``` r
BF_malaria_data_SPDF <- spTransform(BF_malaria_data_SPDF, crs(BF_Adm_1))

# Check the new;y projected object
BF_malaria_data_SPDF
```

    ## class       : SpatialPointsDataFrame 
    ## features    : 109 
    ## extent      : -5.45, 1.85839, 9.95, 14.9722  (xmin, xmax, ymin, ymax)
    ## coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
    ## variables   : 2
    ## names       : examined, positives 
    ## min values  :       56,         2 
    ## max values  :      998,       916

Now we can re-run the over command

``` r
BF_Adm_1_per_point <- over(BF_malaria_data_SPDF, BF_Adm_1)
```

This gives us a table where each row represents a point from
`BF_malaria_data_SPDF` and columns represent the data from `BF_Adm_1`.
Let’s take a
    look

``` r
head(BF_Adm_1_per_point)
```

    ##   GID_0       NAME_0   GID_1       NAME_1 VARNAME_1 NL_NAME_1 TYPE_1
    ## 1   BFA Burkina Faso BFA.2_1     Cascades      <NA>      <NA> Région
    ## 2   BFA Burkina Faso BFA.2_1     Cascades      <NA>      <NA> Région
    ## 3   BFA Burkina Faso BFA.2_1     Cascades      <NA>      <NA> Région
    ## 4   BFA Burkina Faso BFA.2_1     Cascades      <NA>      <NA> Région
    ## 5   BFA Burkina Faso BFA.9_1 Haut-Bassins      <NA>      <NA> Région
    ## 6   BFA Burkina Faso BFA.2_1     Cascades      <NA>      <NA> Région
    ##   ENGTYPE_1 CC_1 HASC_1
    ## 1    Region <NA>  BF.CD
    ## 2    Region <NA>  BF.CD
    ## 3    Region <NA>  BF.CD
    ## 4    Region <NA>  BF.CD
    ## 5    Region <NA>  BF.HB
    ## 6    Region <NA>  BF.CD

Now we can use this to calculate admin unit specific statistics. We
might be interested in the number of sites per admin unit. To get that,
we could just create a frequency table

``` r
table(BF_Adm_1_per_point$NAME_1)
```

    ## 
    ## Boucle du Mouhoun          Cascades            Centre        Centre-Est 
    ##                13                 6                 5                 2 
    ##       Centre-Nord      Centre-Ouest        Centre-Sud               Est 
    ##                 9                 5                10                11 
    ##      Haut-Bassins              Nord   Plateau-Central             Sahel 
    ##                 5                 7                 4                20 
    ##         Sud-Ouest 
    ##                12

Or we can use the `tapply` function for more complex calculations.
`tapply` allows us to apply a function across groups. Let’s look at the
number examined per admin
unit

``` r
Nex_per_Adm1 <- tapply(BF_malaria_data_SPDF$examined, BF_Adm_1_per_point$NAME_1, sum)
```

Now let’s get the number of positives by admin
unit

``` r
Npos_per_Adm1 <- tapply(BF_malaria_data_SPDF$positives, BF_Adm_1_per_point$NAME_1, sum)
```

From these numbers, we can calculate the prevalence per province

``` r
prev_per_Adm1 <- Npos_per_Adm1 / Nex_per_Adm1
```

If you want to merge these provincial prevalence estimates back into the
province object `BF_Adm_1` it is best practice to create a new table of
prevalence by provice with unique ID for each province. That unique ID
can be used to relate and merge the data with `BF_Adm_1`.

First convert your prev\_per\_Adm1 vector into a dataframe with an ID
column

``` r
prev_per_Adm1_df <- data.frame(NAME_1 = names(prev_per_Adm1),
                               prevalence = prev_per_Adm1,
                               row.names=NULL)
```

Now merge this with the `BF_Adm_1` data frame

``` r
BF_Adm_1 <- merge(BF_Adm_1, prev_per_Adm1_df,
                  by = "NAME_1")
```

You can now see that the additional `prevalence` field has been
    added

``` r
head(BF_Adm_1)
```

    ##              NAME_1 GID_0       NAME_0   GID_1 VARNAME_1 NL_NAME_1 TYPE_1
    ## 1 Boucle du Mouhoun   BFA Burkina Faso BFA.1_1      <NA>      <NA> Région
    ## 2          Cascades   BFA Burkina Faso BFA.2_1      <NA>      <NA> Région
    ## 3            Centre   BFA Burkina Faso BFA.7_1      <NA>      <NA> Région
    ## 4        Centre-Est   BFA Burkina Faso BFA.3_1      <NA>      <NA> Région
    ## 5       Centre-Nord   BFA Burkina Faso BFA.4_1      <NA>      <NA> Région
    ## 6      Centre-Ouest   BFA Burkina Faso BFA.5_1      <NA>      <NA> Région
    ##   ENGTYPE_1 CC_1 HASC_1 prevalence
    ## 1    Region <NA>  BF.BO  0.3613746
    ## 2    Region <NA>  BF.CD  0.2103465
    ## 3    Region <NA>  BF.CT  0.2598187
    ## 4    Region <NA>  BF.CE  0.4885057
    ## 5    Region <NA>  BF.CN  0.6099883
    ## 6    Region <NA>  BF.CO  0.4769231

We can now plot province colored by prevalence. Let’s use the leaflet
package

    # First define a color palette based on prevalence
    colorPal <- colorQuantile(wes_palette("Zissou1")[1:5], BF_malaria_data_SPDF$infection_prevalence, n = 5)
    
    # Plot with leaflet
    leaflet() %>% addTiles() %>% addPolygons(data=BF_Adm_1, 
                                             col=colorPal(BF_Adm_1$prevalence),
                                             fillOpacity=0.6)

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/figure-gfm/leaflet_admin1_prev.png)


# Manipulating raster data

You’ve now seen how to subset polygons and relate point and polygon
data. Now we are going to look at basic manipulations of raster data. We
are going to load 2 raster file, elevation and land use for Burkina
Faso.

``` r
# Get elevation using the getData function from the raster package
BF_elev <- raster::getData("alt", country="BF")
plot(BF_elev)
```

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/week2_files/figure-gfm/unnamed-chunk-17-1.png)<!-- -->

``` r
# Land use (# For information on land use classifications see http://due.esrin.esa.int/files/GLOBCOVER2009_Validation_Report_2.2.pdf)
BF_land_use <- raster("https://github.com/HughSt/HughSt.github.io/blob/master/course_materials/week2/Lab_files/BF_land_use.tif?raw=true")
BF_land_use
```

    ## class       : RasterLayer 
    ## dimensions  : 2059, 2864, 5896976  (nrow, ncol, ncell)
    ## resolution  : 309, 316  (x, y)
    ## extent      : -615812.1, 269163.9, 1049582, 1700226  (xmin, xmax, ymin, ymax)
    ## coord. ref. : +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs 
    ## data source : https://github.com/HughSt/HughSt.github.io/blob/master/course_materials/week2/Lab_files/BF_land_use.tif?raw=true 
    ## names       : BF_land_use.tif.raw.true 
    ## values      : 14, 210  (min, max)

``` r
#Plot the land use raster
plot(BF_land_use)
```

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/week2_files/figure-gfm/unnamed-chunk-17-2.png)<!-- -->

``` r
# For a break down of the classes in BF aka how often each land use type occurs in BF
#(Note: this is just the number of pixels per land use type - NOT acres)
table(BF_land_use[]) 
```

    ## 
    ##      14      20      30      40      60     110     120     130     140 
    ##  818365 1316689  807648      89  207124  458004   56383 1120216  684233 
    ##     150     180     190     200     210 
    ##  147957   46527    2509  170739   11363

## Resampling rasters

Its good practice to resample rasters to the same extent and resolution
(i.e. same grid). This makes it easier to deal with later and to relate
rasters to each other. The `resample` command in the `raster` package
makes this process easy. The default method is bilinear interpolation,
which doesn’t make sense for our categorical variable, so we should use
the nearest neighbour function
    ’ngb

    BF_land_use_resampled <- resample(BF_land_use, BF_elev, method="ngb") 

Why might they not intercect?? Hint: check the projections…

``` r
crs(BF_land_use) # Mercator
```

    ## CRS arguments:
    ##  +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0
    ## +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs

``` r
crs(BF_elev) # WGS84
```

    ## CRS arguments:
    ##  +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0

To reproject a raster, you can use the `projectRaster` function

``` r
BF_land_use <- projectRaster(BF_land_use, BF_elev, method="ngb")
```

Now try resampling

``` r
BF_land_use_resampled <- resample(BF_land_use, BF_elev, method="ngb") 

# Get summaries of both raster objects
BF_land_use_resampled
```

    ## class       : RasterLayer 
    ## dimensions  : 708, 972, 688176  (nrow, ncol, ncell)
    ## resolution  : 0.008333333, 0.008333333  (x, y)
    ## extent      : -5.6, 2.5, 9.3, 15.2  (xmin, xmax, ymin, ymax)
    ## coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
    ## data source : in memory
    ## names       : BF_land_use.tif.raw.true 
    ## values      : 14, 210  (min, max)

``` r
BF_elev
```

    ## class       : RasterLayer 
    ## dimensions  : 708, 972, 688176  (nrow, ncol, ncell)
    ## resolution  : 0.008333333, 0.008333333  (x, y)
    ## extent      : -5.6, 2.5, 9.3, 15.2  (xmin, xmax, ymin, ymax)
    ## coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
    ## data source : /Users/sturrockh/Documents/Work/MEI/DiSARM/GitRepos/spatial-epi-course/_posts/BFA_msk_alt.grd 
    ## names       : BFA_msk_alt 
    ## values      : 143, 704  (min, max)

## Manipulating rasters

It is often the case that we want to change the resolution of a raster
for analysis. For example, for computational reasons we might want to
work at a coarser resolution. First, let’s check the resolution

``` r
res(BF_elev) # in decimal degrees. 1 dd roughly 111km at the equator
```

    ## [1] 0.008333333 0.008333333

Let’s aggregate (make lower resolution) by a factor of
10

``` r
BF_elev_low_res <- aggregate(BF_elev, fact = 10) # by default, calculates mean
res(BF_elev_low_res)
```

    ## [1] 0.08333333 0.08333333

``` r
plot(BF_elev_low_res)
```

![](week2_files/figure-gfm/unnamed-chunk-22-1.png)<!-- -->

You can change the values of the pixels easily. For example, if you want
to change the `BF_elev` raster from its native meters to feet, you can
mulitply by 3.28

``` r
BF_elev_feet <- BF_elev*3.28
plot(BF_elev_feet)
```

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/week2_files/figure-gfm/unnamed-chunk-23-1.png)<!-- -->

Similarly, you can categorize raster values

``` r
BF_elev_categorized <- cut(BF_elev, 4)
plot(BF_elev_categorized)
```

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/week2_files/figure-gfm/unnamed-chunk-24-1.png)<!-- -->

If a raster is the same resolution and extent, you can perform joint
operations on them, for example subtract values of one from
another

``` r
new_raster <- BF_elev - BF_land_use_resampled # Meaningless! Just for illustrative purposes..
plot(new_raster)
```

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/week2_files/figure-gfm/unnamed-chunk-25-1.png)<!-- -->

\#Extracting data From rasters Now let’s extract values of elevation at
each survey point. You can use the `extract` function from the raster
package and insert the extracted values as a new field on
`BF_malaria_data_SPDF`

``` r
BF_malaria_data_SPDF$elev <- extract(BF_elev, BF_malaria_data_SPDF)
BF_malaria_data_SPDF# now has 3 variables
```

    ## class       : SpatialPointsDataFrame 
    ## features    : 109 
    ## extent      : -5.45, 1.85839, 9.95, 14.9722  (xmin, xmax, ymin, ymax)
    ## coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
    ## variables   : 3
    ## names       : examined, positives, elev 
    ## min values  :       56,         2,  226 
    ## max values  :      998,       916,  542

You can also extract values using polygons e.g to get admin 1 level
elevations. You just have to define a function to apply, otherwise you
get all the pixel values per polygon. For very large rasters, check out
the `velox`
package.

``` r
BF_Adm_1$elev <- extract(BF_elev, BF_Adm_1, fun=mean, na.rm=TRUE) # takes a little longer..
```

# Exploratory spatial analysis

We can now have a quick look at the relationship between prevalence and
elevation. First generate a prevalence
variable

``` r
BF_malaria_data_SPDF$prevalence <- BF_malaria_data_SPDF$positives / BF_malaria_data_SPDF$examined
```

Now you can plot the relationship between prevalence and elevation

``` r
plot(BF_malaria_data_SPDF$elev, BF_malaria_data_SPDF$prevalence)
```

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/week2_files/figure-gfm/unnamed-chunk-29-1.png)<!-- -->

The package `stats` has a neat function `scatter.smooth` which allows
you to scatter plot the relationship with a lowes
curve

``` r
scatter.smooth(BF_malaria_data_SPDF$elev, BF_malaria_data_SPDF$prevalence) 
```

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/week2_files/figure-gfm/unnamed-chunk-30-1.png)<!-- -->

You might also be interested in distances to/from other features
(e.g. health facilities, water). Here we are going to load up a
waterbody layer (obtained via <http://www.diva-gis.org/Data>) and
calculate distance from each
point.

``` r
waterbodies <- readOGR("https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week2/Lab_files/BF_waterbodies.geojson")
```

    ## OGR data source with driver: GeoJSON 
    ## Source: "https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week2/Lab_files/BF_waterbodies.geojson", layer: "OGRGeoJSON"
    ## with 102 features
    ## It has 5 fields

``` r
waterbodies
```

    ## class       : SpatialPolygonsDataFrame 
    ## features    : 102 
    ## extent      : -5.408325, 0.7365644, 11.28443, 15.03562  (xmin, xmax, ymin, ymax)
    ## coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
    ## variables   : 5
    ## names       : ISO,      COUNTRY,                 F_CODE_DES,                             HYC_DESCRI,                 NAME 
    ## min values  : BFA, Burkina Faso,               Inland Water, Non-Perennial/Intermittent/Fluctuating, BOBANTCHOUGOU GOUAYA 
    ## max values  : BFA, Burkina Faso, Land Subject to Inundation,                    Perennial/Permanent,        VOLTA BLANCHE

``` r
plot(waterbodies)
```

![](https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/week2_files/figure-gfm/unnamed-chunk-31-1.png)<!-- -->

The goesphere package has some nice functions such as `dist2Line` which
calculates distance in meters from spatial data recorded using decimal
degrees. Warning: takes a little while to compute

``` r
dist_to_water <- dist2Line(BF_malaria_data_SPDF, waterbodies)
```

This produces a matrix, where each row represents each point in
`BF_malaria_data_SPDF` and the first column is the distance in meters to
the nearest waterbody

``` r
head(dist_to_water)
```

    ##         distance       lon      lat  ID
    ## [1,] 115005.4717 -5.109397 11.36702  85
    ## [2,]  90588.2682 -5.109397 11.36702  85
    ## [3,]  61994.9571 -5.109397 11.36702  85
    ## [4,]  65045.4999 -4.856356 11.28651 101
    ## [5,]    171.3557 -5.061257 11.56241  86
    ## [6,] 123786.1336 -4.847906 11.28443 101

``` r
# Can add to your data frame by extracting the first column
BF_malaria_data_SPDF$dist_to_water <- dist_to_water[,1]
```

If the objects you are interested in calucating distance to are points
as opposed to polygons/lines (as above) you first have to calculate the
distance to every point and then identify the minimum. For example,
imagine waterbodies data was only available as a point dataset (we can
fake this by calculating the centroid of each polygon)

``` r
waterbodies_points <- gCentroid(waterbodies, byid=TRUE)
```

Now calucate a distance matrix showing distances between each
observation and each waterbody point

``` r
dist_matrix <- distm(BF_malaria_data_SPDF, waterbodies_points)
```

Then use the apply function to apply the ‘minimum’ function to each row
(as each row represents the distance of every waterbody point from our
first observation)

``` r
BF_malaria_data_SPDF$dist_to_water_point <- apply(dist_matrix, 1, min)
```
